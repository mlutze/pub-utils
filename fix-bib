#!/usr/bin/env python3
from typing import Any, Optional
import argparse
import os
import shutil
import webbrowser


import bibtexparser
from bibtexparser.library import Library
from bibtexparser.middlewares.middleware import BlockMiddleware
from bibtexparser.model import Block, Entry, Field
from bibtexparser.middlewares.names import NameParts
from bibtexparser.middlewares.names import SeparateCoAuthors, SplitNameParts, MergeCoAuthors, MergeNameParts

from habanero import cn

def log(string):
    """Logs the string to the appropriate stream."""
    print(string)

FIELD_ORDER = [
    "title",
    "author",
    "journal",
    "booktitle",
    "institution",
    "volume",
    "number",
    "year",
    "school",
    "publisher",
    "doi"
]

FIELD_MAP = {
    "article": set(["title", "author", "journal", "volume", "number", "year", "doi"]),
    "phdthesis": set(["title", "author", "year", "school", "doi"]),
    "inproceedings": set(["title", "author", "booktitle", "year", "doi"]),
    "techreport": set(["title", "author", "institution", "year", "doi"]),
    "book": set(["title", "author", "volume", "year", "publisher", "doi"]),
    "incollection": set(["title", "author", "booktitle", "year", "doi"])
}

def get_tex_files(root: str) -> list[str]:
    """Returns the list of TeX files under the given root directory."""
    files: list[str] = []
    for (dir_name, _, file_names) in os.walk(root):
        for file_name in file_names:
            if file_name.endswith(".tex"):
                files.append(os.path.join(dir_name, file_name))
            else:
                pass
    return files

def file_contains(file_name: str, string: str) -> bool:
    """Returns true if the given file contains the given string."""
    with open(file_name) as file:
        for line in file:
            if string in line:
                return True
        else:
            return False

def clean_doi(string: str) -> Optional[str]:
    """Removes any link information from the DOI string. Returns None if the string does not appear to represent a DOI.
    """
    cleaned = string.strip().removeprefix("https://doi.org/").removeprefix("http://doi.org/").removeprefix("doi.org/")
    if cleaned.startswith("10."):
        return cleaned
    else:
        return None

def titlecase_name(name: NameParts) -> NameParts:
    """Converts the name parts to titlecase."""

    def capitalize_mc(name: str) -> str:
        """Capitalizes the name, accounting for prefixes suchas 'Mc'."""
        lower_name = name.lower()
        prefixes = ["mc"]
        for prefix in prefixes:
            if lower_name.startswith(prefix):
                return prefix.capitalize() + lower_name.removeprefix(prefix).capitalize()
        else:
            return name.capitalize()

    def capitalize(n: str) -> str:
        """Capitalizes the name, accounting for hyphenation."""
        parts = n.split("-")
        new_parts = [capitalize_mc(part) for part in parts]
        return "-".join(new_parts)
    
    def mapNone(f):
        def fNone(x):
            if x is None:
                return None
            else:
                return f(x)
        return fNone
    
    def mapList(f):
        def fList(l):
            return [f(x) for x in l]
        return fList

    return NameParts(
        first=mapNone(mapList(capitalize))(name.first),
        von=mapNone(mapList(str.lower))(name.von),
        last=mapNone(mapList(capitalize))(name.last),
        jr=name.jr # TODO too dangerous. leaving as-is
    )

def set_field(entry: Entry, key: str, value: Any) -> Entry:
    new_fields_dict = entry.fields_dict.copy()
    new_fields_dict[key] = Field(key, value)
    new_fields = list(new_fields_dict.values())
    return Entry(
        entry_type=entry.entry_type,
        key=entry.key,
        fields=new_fields
    )

class FormatNamesTransformer(BlockMiddleware):
    def __init__(self):
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "FormatNamesTransformer"

    def transform_entry(self, entry: Entry, library: Library) -> Block:
        author_field = entry.fields_dict.get("author", None)
        if author_field is None:
            return entry
        else:
            author_list = author_field.value
            new_author_list = [titlecase_name(author) for author in author_list]
            if author_list != new_author_list:
                log("Modified author formatting for entry: " + entry.key)
            return set_field(entry, "author", new_author_list)

class FilterUsedTransformer(BlockMiddleware):
    def __init__(self, root):
        self._tex_files = get_tex_files(root)
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "FilterUsedTransformer"
    
    def transform_entry(self, entry: Entry, library: Library) -> Block | None:
        if any(file_contains(file_name, entry.key) for file_name in self._tex_files):
            return entry
        else:
            log("Removing unused entry: " + entry.key)
            return None
        
class OrderFieldTransformer(BlockMiddleware):
    def __init__(self, order):
        self._indices = {}
        for i in range(len(order)):
            self._indices[order[i]] = i
        self._allow_inplace_modification = False

    @staticmethod
    def metadata_key():
        return OrderFieldTransformer(BlockMiddleware)
    
    def transform_entry(self, entry: Entry, library: Library) -> Library:
        fields = entry.fields
        new_fields = sorted(fields, key=lambda f: self._indices.get(f.key, float("inf")))
        return Entry(
            entry_type=entry.entry_type,
            key=entry.key,
            fields=new_fields
        )

class FilterFieldTransformer(BlockMiddleware):
    def __init__(self, map):
        self._map = map
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "FilterOrderFieldTransformer"

    # TODO this is a bug. should report to library authors
    def transform(self, library: "Library") -> "Library":
        blocks = []
        for b in library.blocks:
            block = self.transform_block(b, library)
            if block is None:
                pass
            else:
                blocks.append(block)
        return Library(blocks=blocks)
    
    def transform_entry(self, entry: Entry, library: Library) -> Block:
        keys = self._map.get(entry.entry_type, None)
        if keys is None:
            log("Not modifying unknown entry type: " + entry.entry_type)
            return entry
        else:
            new_fields = [field for field in entry.fields if field.key in keys]
            return Entry(
                entry_type=entry.entry_type,
                key=entry.key,
                fields=new_fields
            )

class TodoFieldTransformer(BlockMiddleware):
    def __init__(self, map):
        self._map = map
        self._allow_inplace_modification = True
    
    @staticmethod
    def metadata_key():
        return "TodoFieldTransformer"
    
    def transform_entry(self, entry: Entry, library: Library) -> Block:
        keys = self._map.get(entry.entry_type, None)
        if keys is None:
            log("Not modifying unknown entry type: " + entry.entry_type)
            return entry
        else:
            present_keys = set(entry.fields_dict.keys())
            missing_keys = [key for key in keys if key not in present_keys]
            missing_fields = [Field(key, "TODO") for key in missing_keys]
            new_fields = entry.fields + missing_fields
            return Entry(
                entry_type=entry.entry_type,
                key=entry.key,
                fields=new_fields
            )

class LookupDoiTransformer(BlockMiddleware):
    def __init__(self, *, browserless: bool):
        self._browserless = browserless
        self._allow_inplace_modification = True
    
    @staticmethod
    def metadata_key():
        return "LookupDoiTransformer"

    def transform_entry(self, entry: Entry, library: Library) -> Block:
        doi = entry.fields_dict.get("doi", None)
        if doi is not None:
            return entry
        else:
            print("Entry missing DOI: " + entry.key)
            title = entry.fields_dict.get("title", None)
            if title is None:
                print("Cannot look up DOI for titleless entry: " + entry.key)
                return entry
            else:
                if not self._browserless:
                    print("Let me Google that for you...")
                    webbrowser.open("https://scholar.google.com/scholar?q=" + title.value)
                raw_doi = input("Enter the DOI or leave blank to skip: ")
                if raw_doi.strip() == "":
                    print("Skipping DOI")
                    return entry
                else:
                    while True:
                        doi_string = clean_doi(raw_doi)
                        if doi_string is None:
                            print("Invalid DOI.")
                            raw_doi = input("Enter the DOI or leave blank to skip: ")
                            if raw_doi.strip() == "":
                                print("Skipping DOI")
                                return entry
                            else:
                                pass
                        else:
                            break
                    return set_field(entry, "doi", doi_string)

class LookupCitationTransformer(BlockMiddleware):
    def __init__(self, *, clobber: bool):
        self._clobber = clobber
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "LookupFieldsTransformer"

    def transform_entry(self, entry: Entry, library: Library) -> Block:
        doi = entry.fields_dict.get("doi", None)
        if doi is None:
            log("Cannot look up citation for DOIless entry: " + entry.key)
            return entry
        else:
            crossref_bibtex = cn.content_negotiation(doi.value)
            if crossref_bibtex is None:
                log("Not modifying entry with invalid doi:" + entry.key)
                return entry
            crossref_entry = bibtexparser.parse_string(crossref_bibtex).entries[0]
            if self._clobber:
                return Entry(crossref_entry.entry_type, entry.key, crossref_entry.fields)
            else:
                new_fields = entry.fields_dict.copy()
                crossref_fields = crossref_entry.fields_dict
                for field in crossref_fields:
                    if field not in new_fields:
                        new_fields[field] = crossref_fields[field]
                return Entry(entry.entry_type, key=entry.key, fields = list(new_fields.values()))

def main():
    parser = argparse.ArgumentParser(
        description="Clean up a BibTeX file according to Flix contributor conventions."
    )
    parser.add_argument("bib_file")
    parser.add_argument("-f", "--filter", action="store_true", help="filter down to required fields")
    parser.add_argument("-i", "--interactive", action="store_true", help="run in interactive mode")
    parser.add_argument("-l", "--lookup", action="store_true", help="look up citations via CrossRef")
    parser.add_argument("-n", "--names", action="store_true", help="format author names")
    parser.add_argument("-o", "--output", action="store", help="specify an output file (default in-place)")
    parser.add_argument("-r", "--replace", action="store_true", help="replace existing fields with CrossRef fields")
    parser.add_argument("-t", "--todo", action="store_true", help="mark required fields with TODO")
    parser.add_argument("-u", "--unused", action="store_true", help="remove unused entries")

    parser.add_argument("-X", "--browserless", action="store_true", help=argparse.SUPPRESS)

    args = parser.parse_args()

    bib_file_name = args.bib_file

    if args.output is None:
        backup_file_name = bib_file_name + ".bak"
        shutil.copyfile(bib_file_name, backup_file_name)
        out_file = bib_file_name
    else:
        out_file = args.output


    db = bibtexparser.parse_file(bib_file_name)

    middleware = []
    if args.unused:
        middleware.append(FilterUsedTransformer("."))
    if args.interactive:
        middleware.append(LookupDoiTransformer(browserless=args.browserless))
    if args.lookup:
        middleware.append(LookupCitationTransformer(clobber=args.replace))
    if args.filter:
        middleware.append(FilterFieldTransformer(FIELD_MAP))
    if args.todo:
        middleware.append(TodoFieldTransformer(FIELD_MAP))
    middleware.append(OrderFieldTransformer(FIELD_ORDER))
    if args.names:
        middleware.append(SeparateCoAuthors())
        middleware.append(SplitNameParts())
        middleware.append(FormatNamesTransformer())
        middleware.append(MergeNameParts())
        middleware.append(MergeCoAuthors())

    bibtexparser.write_file(out_file, library=db, append_middleware=middleware)

if __name__ == "__main__":
    main()