#!/usr/bin/env python3
from typing import Collection
import argparse
import os
import shutil
import webbrowser


import bibtexparser
from bibtexparser.library import Library
import bibtexparser.middlewares
import bibtexparser.middlewares.middleware
from bibtexparser.model import Block, Entry, Field

from habanero import cn

def log(string):
    print(string)

FIELD_MAP = {
    "article": ["title", "author", "journal", "volume", "number", "year", "doi"],
    "phdthesis": ["title", "author", "year", "school", "doi"],
    "inproceedings": ["title", "author", "booktitle", "year", "doi"],
    "techreport": ["title", "author", "institution", "year", "doi"],
    "book": ["title", "author", "volume", "year", "publisher", "doi"],
    "incollection": ["title", "author", "booktitle", "year", "doi"]
}

def get_tex_files(root):
    files = []
    for (dir_name, _, file_names) in os.walk(root):
        for file_name in file_names:
            if file_name.endswith(".tex"):
                files.append(os.path.join(dir_name, file_name))
            else:
                pass
    return files

def file_contains(file_name, string):
    with open(file_name) as file:
        for line in file:
            if string in line:
                return True
        else:
            return False

def clean_doi(string: str):
    cleaned = string.strip().removeprefix("https://doi.org/").removeprefix("http://doi.org/").removeprefix("doi.org/")
    if cleaned.startswith("10."):
        return cleaned
    else:
        return None

class FilterUsedTransformer(bibtexparser.middlewares.middleware.BlockMiddleware):
    def __init__(self, root):
        self._tex_files = get_tex_files(root)
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "FilterUsedTransformer"
    
    def transform_entry(self, entry: Entry, library: Library) -> Block | Collection[Block] | None:
        if any(file_contains(file_name, entry.key) for file_name in self._tex_files):
            return entry
        else:
            log("Removing unused entry: " + entry.key)
            return None

class FilterOrderFieldTransformer(bibtexparser.middlewares.middleware.BlockMiddleware):
    def __init__(self, map):
        self._map = map
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "FilterOrderFieldTransformer"

    # TODO this is a bug. should report to library authors
    def transform(self, library: "Library") -> "Library":
        blocks = []
        for b in library.blocks:
            block = self.transform_block(b, library)
            if block is None:
                pass
            else:
                blocks.append(block)
        return Library(blocks=blocks)
    
    def transform_entry(self, entry: Entry, library: Library) -> Block | Collection[Block] | None:
        keys = self._map.get(entry.entry_type, None)
        if keys is None:
            log("Not modifying unknown entry type: " + entry.entry_type)
            return entry
        else:
            def get_field(key):
                if key in entry.fields_dict:
                    return Field(key, entry.fields_dict[key].value)
                else:
                    log("Marking missing key '" + key + "' for entry: " + entry.key)
                    return Field(key, "TODO")
            fields = [get_field(key) for key in keys]
            return Entry(entry.entry_type, entry.key, fields)

class LookupDoiTransformer(bibtexparser.middlewares.middleware.BlockMiddleware):
    def __init__(self, interactive: bool):
        self._interactive = interactive
        self._allow_inplace_modification = True

    @staticmethod
    def metadata_key():
        return "LookupDoiTransformer"

    def transform_entry(self, entry: Entry, library: Library) -> Block | Collection[Block] | None:
        doi = entry.fields_dict.get("doi", None)
        if doi is None:
            print("entry " + entry.key + " missing DOI")
            title = entry.fields_dict.get("title", None)
            if self._interactive:
                if title is None:
                    print("Cannot look up DOI for titleless entry: " + entry.key)
                    return entry
                else:
                    print("Let me Google that for you...")
                    webbrowser.open("https://scholar.google.com/scholar?q=" + title.value)
                    raw_doi = input("Enter the DOI or leave blank to skip: ")
                    if raw_doi.strip() == "":
                        print("Skipping DOI")
                        return entry
                    else:
                        while True:
                            doi_string = clean_doi(raw_doi)
                            if doi_string is None:
                                print("Invalid DOI.")
                                raw_doi = input("Enter the DOI or leave blank to skip: ")
                                if raw_doi.strip() == "":
                                    print("Skipping DOI")
                                    return entry
                                else:
                                    pass
                            else:
                                break
            else:
                return entry
        else:
            doi_string = doi.value

        crossref_bibtex = cn.content_negotiation(doi_string)
        if crossref_bibtex is None:
            log("Not modifying entry with invalid doi:" + entry.key)
            return entry
        crossref_entry = bibtexparser.parse_string(crossref_bibtex).entries[0]
        return Entry(crossref_entry.entry_type, entry.key, crossref_entry.fields)

def main():
    parser = argparse.ArgumentParser(
        description="Clean up a BibTeX file according to Flix contributor conventions."
    )
    parser.add_argument("bib_file")
    parser.add_argument("-i", "--interactive", action="store_true", help="run in interactive mode")

    args = parser.parse_args()

    bib_file_name = args.bib_file

    backup_file_name = bib_file_name + ".bak"
    shutil.copyfile(bib_file_name, backup_file_name)


    db = bibtexparser.parse_file(bib_file_name)

    middleware = [
        FilterUsedTransformer("."),
        LookupDoiTransformer(),
        FilterOrderFieldTransformer(FIELD_MAP)
        
    ]
    bibtexparser.write_file(bib_file_name, library=db, append_middleware=middleware)

if __name__ == "__main__":
    main()